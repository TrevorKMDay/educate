#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @inheritParams StatWatercolorDensity2
#'
#' @section Aesthetics:
#' These stat uses  `geom_line()` so support the
#' same aesthetics: `alpha`, `colour`, `linetype` and
#' `size`.
#'
#' @importFrom dplyr %>%
#' @export
stat_watercolor_density2 <- function(mapping = NULL, data = NULL, geom = "line",
position = "identity", na.rm = TRUE,
inherit.aes = TRUE, k = 1000,
alpha = 0.03,
model = "none", ...) {
ggplot2::layer(
stat = StatWatercolorDensity2,
data = data,
mapping = mapping,
geom = geom,
position = position,
inherit.aes = inherit.aes,
params = list(
na.rm = na.rm,
k = k,
alpha = alpha,
model = model,
...)
)
}
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
#' Watercolor Bootstrapped Density (Multicolor)
#'
#' This function creates a confidence envelope for the empirical density by bootstrapping from the data.
#' Transparency is used to indicate the level of uncertainty.
#'
#' @inheritParams ggplot2::stat_identity
#' @param k Number of bootstrapped smoothers. The default is 1000.
#' @param color Color for the bootstrapped fitted lines that make up the confidence envelope. The
#'     default is `color="#1D91C0"`
#' @param alpha Transparency level for the paths that make up the bootstrapped fitted lines. This may
#'    need to be adjusted if the argument `k=` is changed. The default value is `alpha=0.03`.
#' @param model The model to bootstrap from. The default is `model="none"` which bootstraps from the data.
#'     Using `model="normal"` draws repeated samples from a normal distribution with parameters based on the
#'     ML estimates from the data.
#'
#' @importFrom dplyr %>%
#'
#' @export
StatWatercolorDensity2 <- ggplot2::ggproto("StatWatercolorDensity", ggplot2::Stat,
# Required aesthetics
required_aes = c("x"),
non_missing_aes = c("y", "group", "color"),
default_aes = ggplot2::aes(y = stat(y), group = stat(group), color = stat(color)),
# Computations
compute_group = function(data, scales, k = 1000, na.rm = TRUE,
alpha = 0.03, model = "none",
...) {
if (length(unique(data$x)) < 2) {
# Not enough data to perform fit
return(new_data_frame())
}
# Compute bounds on data
lower_bound = min(data$x, na.rm = TRUE)
upper_bound = max(data$x, na.rm = TRUE)
d1 = data.frame(
x = data$x
)
if(model == "normal") {
###################################################################
# model = "normal"
###################################################################
# Get parameter estimates
mu_hat = MASS::fitdistr(na.omit(data$x), "normal")$estimate[[1]]
sigma_hat = MASS::fitdistr(na.omit(data$x), "normal")$estimate[[2]]
n = length(data$x)
# Compute densities of bootstrap samples
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(group = 1:k) %>%
dplyr::group_by(group) %>%
dplyr::mutate(
d = list(data %>% dplyr::sample_frac(size = 1, replace = TRUE))
) %>%
tidyr::unnest() %>%
dplyr::do(broom::tidy(density(.$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::group_by(x) %>%
dplyr::mutate(
norm_dens = dnorm(x, mean = mu_hat, sd = sigma_hat),
dens.scaled = abs(y - norm_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
} else{
###################################################################
# model = "none"
###################################################################
# Bootstap
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(group = 1:k) %>%
dplyr::group_by(group) %>%
dplyr::mutate(
d = list(d1 %>% dplyr::sample_frac(size = 1, replace = TRUE))
) %>%
tidyr::unnest() %>%
dplyr::group_by(group) %>%
dplyr::do(broom::tidy(density(.$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup()
# Get empirical densities
my_dens = data.frame(
x        = density(data$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE)$x,
emp_dens = density(data$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE)$y
)
# Compute limits for conditional densities for better color gradient
M = mean(densities_within$y)
SD = sd(densities_within$y)
low_limit = M - 3 * SD
upp_limit = M + 3 * SD
# Filter out extremes for better coloring
densities_within = densities_within %>%
dplyr::left_join(my_dens, by = "x") %>%
dplyr::filter(y > low_limit, y < upp_limit) %>%
dplyr::group_by(x) %>%
dplyr::mutate(
dens.scaled = abs(y - emp_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
}
# Output data for plotting
data.frame(
x = densities_within$x,
y = densities_within$y,
group = densities_within$group,
color = densities_within$dens.scaled2
)
}
)
#' Stat Method for Watercolor Bootstrapped Smoother
#'
#' This function creates a visually regression smoother, also called a watercolor plot. The initial idea
#' came from Solomon Hsiang.
#'
#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @inheritParams StatWatercolorDensity2
#'
#' @section Aesthetics:
#' These stat uses  `geom_line()` so support the
#' same aesthetics: `alpha`, `colour`, `linetype` and
#' `size`.
#'
#' @importFrom dplyr %>%
#' @export
stat_watercolor_density2 <- function(mapping = NULL, data = NULL, geom = "line",
position = "identity", na.rm = TRUE,
inherit.aes = TRUE, k = 1000,
alpha = 0.03,
model = "none", ...) {
ggplot2::layer(
stat = StatWatercolorDensity2,
data = data,
mapping = mapping,
geom = geom,
position = position,
inherit.aes = inherit.aes,
params = list(
na.rm = na.rm,
k = k,
alpha = alpha,
model = model,
...)
)
}
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000, color = stat("color")) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000, aes(color = stat("color"))) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
#' Watercolor Bootstrapped Density (Multicolor)
#'
#' This function creates a confidence envelope for the empirical density by bootstrapping from the data.
#' Transparency is used to indicate the level of uncertainty.
#'
#' @inheritParams ggplot2::stat_identity
#' @param k Number of bootstrapped smoothers. The default is 1000.
#' @param color Color for the bootstrapped fitted lines that make up the confidence envelope. The
#'     default is `color="#1D91C0"`
#' @param alpha Transparency level for the paths that make up the bootstrapped fitted lines. This may
#'    need to be adjusted if the argument `k=` is changed. The default value is `alpha=0.03`.
#' @param model The model to bootstrap from. The default is `model="none"` which bootstraps from the data.
#'     Using `model="normal"` draws repeated samples from a normal distribution with parameters based on the
#'     ML estimates from the data.
#'
#' @importFrom dplyr %>%
#'
#' @export
StatWatercolorDensity2 <- ggplot2::ggproto("StatWatercolorDensity", ggplot2::Stat,
# Required aesthetics
required_aes = c("x"),
default_aes = ggplot2::aes(y = stat(y), group = stat(group), color = stat(color)),
# Computations
compute_group = function(data, scales, k = 1000, na.rm = TRUE,
alpha = 0.03, model = "none",
...) {
if (length(unique(data$x)) < 2) {
# Not enough data to perform fit
return(new_data_frame())
}
# Compute bounds on data
lower_bound = min(data$x, na.rm = TRUE)
upper_bound = max(data$x, na.rm = TRUE)
d1 = data.frame(
x = data$x
)
if(model == "normal") {
###################################################################
# model = "normal"
###################################################################
# Get parameter estimates
mu_hat = MASS::fitdistr(na.omit(data$x), "normal")$estimate[[1]]
sigma_hat = MASS::fitdistr(na.omit(data$x), "normal")$estimate[[2]]
n = length(data$x)
# Compute densities of bootstrap samples
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(group = 1:k) %>%
dplyr::group_by(group) %>%
dplyr::mutate(
d = list(data %>% dplyr::sample_frac(size = 1, replace = TRUE))
) %>%
tidyr::unnest() %>%
dplyr::do(broom::tidy(density(.$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup() %>%
dplyr::group_by(x) %>%
dplyr::mutate(
norm_dens = dnorm(x, mean = mu_hat, sd = sigma_hat),
dens.scaled = abs(y - norm_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
} else{
###################################################################
# model = "none"
###################################################################
# Bootstap
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(group = 1:k) %>%
dplyr::group_by(group) %>%
dplyr::mutate(
d = list(d1 %>% dplyr::sample_frac(size = 1, replace = TRUE))
) %>%
tidyr::unnest() %>%
dplyr::group_by(group) %>%
dplyr::do(broom::tidy(density(.$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup()
# Get empirical densities
my_dens = data.frame(
x        = density(data$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE)$x,
emp_dens = density(data$x, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE)$y
)
# Compute limits for conditional densities for better color gradient
M = mean(densities_within$y)
SD = sd(densities_within$y)
low_limit = M - 3 * SD
upp_limit = M + 3 * SD
# Filter out extremes for better coloring
densities_within = densities_within %>%
dplyr::left_join(my_dens, by = "x") %>%
dplyr::filter(y > low_limit, y < upp_limit) %>%
dplyr::group_by(x) %>%
dplyr::mutate(
dens.scaled = abs(y - emp_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
}
# Output data for plotting
data.frame(
x = densities_within$x,
y = densities_within$y,
group = densities_within$group,
color = densities_within$dens.scaled2
)
}
)
#' Stat Method for Watercolor Bootstrapped Smoother
#'
#' This function creates a visually regression smoother, also called a watercolor plot. The initial idea
#' came from Solomon Hsiang.
#'
#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @inheritParams StatWatercolorDensity2
#'
#' @section Aesthetics:
#' These stat uses  `geom_line()` so support the
#' same aesthetics: `alpha`, `colour`, `linetype` and
#' `size`.
#'
#' @importFrom dplyr %>%
#' @export
stat_watercolor_density2 <- function(mapping = NULL, data = NULL, geom = "line",
position = "identity", na.rm = TRUE,
inherit.aes = TRUE, k = 1000,
alpha = 0.03,
model = "none", ...) {
ggplot2::layer(
stat = StatWatercolorDensity2,
data = data,
mapping = mapping,
geom = geom,
position = position,
inherit.aes = inherit.aes,
params = list(
na.rm = na.rm,
k = k,
alpha = alpha,
model = model,
...)
)
}
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000, aes(color = stat("color"))) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
ggplot(data = keith, aes(x = gpa)) + stat_watercolor_density2(k = 1000) + scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
library(educate)
ggplot(data = education, aes(x = salary)) + stat_watercolor_density(k = 1000)
ggplot(data = education, aes(x = salary)) + stat_watercolor_density2(k = 1000)+ scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(9, "YlGnBu")))
watercolor_density(data = education, x = salary, multicolor = TRUE)
#' Density Plot with Bootstrapped Confidence Envelope
#'
#' This function creates an empirical density plot along with options to also include
#' a visually weighted confidence envelope.
#'
#' @param data Dataframe
#' @param x A column name in the dataframe. This should be unquoted.
#' @param k Number of bootstrap samples. The default value is 1000.
#' @param model Character string indicating the type of bootstrapped confidence envelope to display.
#'    Its default value is `model="none"`. If `model="normal"` then a parametric bootstrap confidence
#'    envelope based on random draws from a normal distribution with ML estimated parameters will be
#'    generated.
#' @param se_boot Logical value to indicate whether the bootstrapped density paths that make up the
#'    confidence envelope should be displayed. The default value is `se.boot=TRUE`.
#' @param color Color for the bootstrapped density paths that make up the confidence envelope. The
#'     default is `color="#1D91C0"`
#' @param alpha Transparency level for the paths that make up the bootstrapped confidence envelope. This may
#'    need to be adjusted if the argument k= is changed. The default value is `alpha=0.03`.
#' @param multicolor Logical value indicating whether the confidence envelope should be multicolored.
#'    The default value is `multicolor=FALSE` which produces a monocolored envelope.
#' @param palette Color palette used if `multicolor=TRUE`. This defaults to the 9-color YlGnBu palette
#'    from \link{RColorBrewer}; `palette=RColorBrewer::brewer.pal(9, "YlGnBu")`.
#' @param rug Logical value indicating whether the empirical observations should be plotted as a rug.
#'    The default value is `rug=FALSE`.
#' @param rug_color Color for the rug plot. The default is `rug_color="black"`.
#' @param emp_dens_color Color of the line for the density plot of the empirical data.
#'     The default is `emp_dens_color="black"`.
#' @param emp_dens_size Size of the line for the density plot of the empirical data.
#'     The default value is `emp_dens_size=0.5`.
#'
#' @return A ggplot object giving the density plot
#'
#' @importFrom dplyr %>%
#'
#' @export
watercolor_density = function(data, x, k = 1000, model = "none",
se_boot = TRUE, color = "#1D91C0", alpha = 0.03,
multicolor = FALSE, palette = RColorBrewer::brewer.pal(9, "YlGnBu"),
emp_dens_color = "black", emp_dens_size = 0.5,
rug = FALSE, rug_color = "black", ...){
var  = eval(substitute(x), data) # Get variable
var2 = substitute(.$x)           # Get variable for density()
# Tests
if(!is.numeric(var)) return("x is non-numeric") # Check that input is numeric
if(length(var) == 0) return("x has no data")
if(model == "none"){
if(se_boot){
lower_bound = min(var, na.rm = TRUE)
upper_bound = max(var, na.rm = TRUE)
# Compute densities of bootstrap samples
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(bs = 1:k) %>%
dplyr::group_by(bs) %>%
dplyr::mutate(
data = list(data %>% dplyr::sample_frac(size = 1, replace = TRUE))
) %>%
tidyr::unnest() %>%
dplyr::group_by(bs) %>%
dplyr::do(broom::tidy(density(eval(var2), from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup()
# Rename variables
names(densities_within)[2] = "X"
names(densities_within)[3] = "dens"
# Compute limits for conditional densities for better color gradient
M = mean(densities_within$dens)
SD = sd(densities_within$dens)
low_limit = M - 3 * SD
upp_limit = M + 3 * SD
if(multicolor){
# Get empirical densities
my_dens = data.frame(
X = density(eval(var), from = min(var, na.rm = TRUE), to = max(var, na.rm = TRUE), n = 128, na.rm = TRUE)$x,
emp_dens = density(eval(var), from = min(var, na.rm = TRUE), to = max(var, na.rm = TRUE), n = 128, na.rm = TRUE)$y
)
# Join with empirical density and create color gradient levels
densities_within = densities_within %>%
dplyr::left_join(my_dens, by = "X") %>%
dplyr::filter(dens > low_limit, dens < upp_limit) %>%
dplyr::group_by(X) %>%
dplyr::mutate(
dens.scaled = abs(dens - emp_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
# Create multicolored watercolor density plot
p = ggplot2::ggplot(data = densities_within, ggplot2::aes(x = X)) +
ggplot2::geom_line(ggplot2::aes(group = bs, y = dens, color = dens.scaled2)) +
ggplot2::scale_color_gradientn("dens.scaled", colors = rev(palette)) +
ggplot2::scale_alpha_continuous(range = c(0.001, 1)) +
ggplot2::stat_density(data = data, ggplot2::aes(x = var), geom = "line", color = emp_dens_color, size = 0.5) +
ggplot2::theme_classic() +
ggplot2::guides(color = FALSE, alpha = FALSE)
} else{
# Filter out extremes for better plotting
densities_within = densities_within %>%
dplyr::filter(dens > low_limit, dens < upp_limit)
# Create monocolored watercolor density plot
p = ggplot2::ggplot(data = densities_within, ggplot2::aes(x = X)) +
ggplot2::geom_path(ggplot2::aes(group = bs, y = dens), color = color, alpha = alpha) +
ggplot2::stat_density(data = data, ggplot2::aes(x = var), geom = "line", color = emp_dens_color, size = emp_dens_size) +
ggplot2::xlab(deparse(substitute(x))) +
ggplot2::ylab("Probability density") +
ggplot2::theme_classic()
}
} else{
# Create density plot with no enevelope
p = ggplot2::ggplot(data = data, ggplot2::aes(x = var)) +
ggplot2::stat_density(geom = "line", color = emp_dens_color, size = emp_dens_size) +
ggplot2::xlab(deparse(substitute(x))) +
ggplot2::ylab("Probability density") +
ggplot2::theme_classic()
}
}
# Code for generating bootstrap paths from a normal model
if(model == "normal") {
# Get parameter estimates
mu_hat = MASS::fitdistr(na.omit(var), "normal")$estimate[[1]]
sigma_hat = MASS::fitdistr(na.omit(var), "normal")$estimate[[2]]
n = length(var)
lower_bound = mu_hat - 4 * sigma_hat
upper_bound = mu_hat + 4 * sigma_hat
# Compute densities of bootstrap samples
message("Computing boostrapped smoothers ...")
flush.console()
densities_within = data.frame(bs = 1:k) %>%
dplyr::group_by(bs) %>%
dplyr::mutate(
data = list(rnorm(n, mu_hat, sigma_hat))
) %>%
tidyr::unnest() %>%
dplyr::group_by(bs) %>%
dplyr::do(broom::tidy(density(.$data, from = lower_bound, to = upper_bound, n = 128, na.rm = TRUE))) %>%
dplyr::ungroup()
names(densities_within)[2] = "X"
names(densities_within)[3] = "dens"
if(multicolor){
densities_within = densities_within %>%
dplyr::group_by(X) %>%
dplyr::mutate(
norm_dens = dnorm(X, mean = mu_hat, sd = sigma_hat),
dens.scaled = abs(dens - norm_dens),
dens.scaled2 = dens.scaled / (max(dens.scaled) - min(dens.scaled))
) %>%
dplyr::ungroup()
# Create multicolored watercolor normal density plot
p = ggplot2::ggplot(data = densities_within, ggplot2::aes(x = X)) +
ggplot2::geom_path(ggplot2::aes(group = bs, y = dens, color = dens.scaled2)) +
ggplot2::scale_color_gradientn("dens.scaled", colors = rev(palette)) +
ggplot2::scale_alpha_continuous(range = c(0.001, 1)) +
ggplot2::stat_density(data = data, ggplot2::aes(x = var), geom = "line", color = emp_dens_color, size = 0.5) +
ggplot2::theme_classic() +
ggplot2::guides(color = FALSE, alpha = FALSE)
} else{
# Create monocolored watercolor normal density plot
p = ggplot2::ggplot(data = densities_within, ggplot2::aes(x = X)) +
geom_path(aes(group = bs, y = dens), color = color, alpha = alpha) +
ggplot2::stat_density(data = data, ggplot2::aes(x = var), geom = "line", color = emp_dens_color, size = emp_dens_size) +
ggplot2::xlab(deparse(substitute(x))) +
ggplot2::ylab("Probability density") +
ggplot2::theme_classic()
}
}
message("Build ggplot figure ...")
flush.console()
if(rug){
p = p + ggplot2::geom_point(data = data, ggplot2::aes(x = var), y = 0, shape = "|", size = 2, color = rug_color)
}
print(p)
}
# sm_density(keith, homework) + theme_bw() + xlab("Time spent on homework")
# sm_density(city, gender)
# sm_density(city, income, boot_envelope = FALSE)
# sm_density(city, seniority, color = "skyblue") + theme_bw()
#
# sm_density(keith, homework, model = "normal") + theme_bw()
# sm_density(city, income, model = "normal", color = "skyblue", rug_color = "red")
##########################################
watercolor_density(data = education, x = salary, multicolor = TRUE)
